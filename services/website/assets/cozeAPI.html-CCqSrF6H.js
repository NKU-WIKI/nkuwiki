import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as r,h as o,o as n}from"./app-guG5bR-m.js";const a={};function s(p,e){return n(),r("div",null,e[0]||(e[0]=[o(`<h1 id="_5千字长文-coze专业版api调用超详细教程-python" tabindex="-1"><a class="header-anchor" href="#_5千字长文-coze专业版api调用超详细教程-python"><span>5千字长文：COZE专业版API调用超详细教程（Python）</span></a></h1><p>DefinitelyFly<br> 随着字节在大模型军备竞赛中一骑绝尘，越来越多的小伙伴开始注意到扣子（COZE）这个强大的智能体工作流搭建平台。然而，不得不说，扣子的官方教程实在是出了名的草率，既没有示例代码，排版布局也十分混乱，扣子基础版、扣子专业版、豆包大模型、火山引擎、火山方舟让人傻傻分不清楚，混乱程度简直令人咋舌。</p><p>本文将提供官方文档没有提供的调用 COZE BOT API 的 Python 代码，关于豆包大模型的调用将在另一篇中详述。</p><p>一、基础知识<br> 首先，扣子分为国内版和海外版，可以调用基础模型不一样，比如海外版可以调用Chat-GPT，但国内版不行。不过，海外版需要用到梯子，所以我们还是先以国内版为例，国内版的官网是这个：</p><p>扣子-AI 智能体开发平台<br><a href="http://xn--www-4m0a.coze.cn/" target="_blank" rel="noopener noreferrer">​www.coze.cn/</a><br> 国内版又分为基础版和专业版（国外版好像是不分的），专业版和基础版登录的入口是不同的，而且你同一个账号下的专业版和基础版是不互通的，也就是说你在基础版里创建的智能体，不会自动出现在专业版的账号里，虽然可以进行迁移，但只能迁移一次，这点是最神奇的。</p><p>专业版和基础版在API调用限制上的区别如下：</p><p>基础版 专业版<br> COZE国内版API 2024年8月15日之后，扣子 API 的免费额度为每个账号 100 次 API 调用。一旦累计调用次数超过免费额度，此账号将无法继续使用任何扣子 API。<br> API 免费额度不适用于通过扣子平台、其他发布渠道或 SDK 产生的请求。 不限制 API 调用次数。<br> 调用发起对话、执行工作流或执行工作流（流式响应）API，根据 Bot 调用次数和方舟模型 Token 消耗收取费用；调用恢复运行工作流，仅根据方舟模型 Token 消耗收取费用；调用其他接口免费。<br> 总结起来就是，免费版有调用次数限制，且总共只有100次。所以如果100次不够用的小伙伴，就只能选择专业版了。</p><p>值得一提的是，专业版每次调用的收费分为两部分：</p><p>bot调用次数，就是调用一次智能体收一次费；<br> 智能体消耗的token数，就是看你智能体里用到的大语言模型消耗的token，这一点和单独调用豆包一样；<br> 不过，虽然是两道收费，但其实也不贵。首先，字节的大模型token收费可以说是国内所有大模型里的地板价了，比那些小厂的甚至可以低2个数量级；其次，智能体调用收费好像是调用一次扣2点，但现在有优惠，50万点1块钱，所以这个费用也就忽略不计了。</p><p>二、创建智能体<br> 本篇文章主要是讲如何通过API来调用你已经创建好的智能体，所以创建智能体的部分就不再赘述啦，网上教程也越来越多，COZE在B站也有官方教程，可以参考一下：</p><p>扣子Coze个人主页<br><a href="http://xn--space-kt3b.bilibili.com/1444391473" target="_blank" rel="noopener noreferrer">​space.bilibili.com/1444391473</a><br> 注意，记得在专业版里创建，因为基础版里创建的话你只有100次的API调用机会。</p><p>专业版里的智能体调用大语言模型需要你创建接入点，这个我会另外出一个教程。</p><p>三、调用的前置准备<br> 在调用COZE的API之前，确保你完成了以下两件事：</p><p>发布 Bot 为 API 服务，发布 Bot 时一定要勾选“Bot as API”；<br> 获取访问令牌，这个在调用API时需要用到；<br> 具体可以参考这个官方文档：</p><p>扣子 - 开发指南 - 准备工作<br><a href="http://xn--www-4m0a.coze.cn/docs/developer_guides/preparation" target="_blank" rel="noopener noreferrer">​www.coze.cn/docs/developer_guides/preparation</a><br> 四、用Python调用Bot API<br> 好，重头戏来了。</p><p>虽然扣子的官方文档写的不咋地，但我还是礼貌性地提供一下，毕竟先看官方文档是一个好习惯：</p><p>扣子 - 开发指南<br><a href="http://xn--www-4m0a.coze.cn/docs/developer_guides/coze_api_overview" target="_blank" rel="noopener noreferrer">​www.coze.cn/docs/developer_guides/coze_api_overview</a><br> （一）导入必要的库<br> import re<br> import requests<br> import json<br> import time<br> import sys<br> 这几个是基础的，当然可能还有其他的，根据你的需求来。</p><p>（二）准备ID信息<br> bot_id = &quot;你的BOT-ID&quot;<br> access_token = &#39;Bearer pat_你的访问令牌&#39;<br> user_id = &quot;你的USER-ID&quot;<br> 如何获取bot_id和user_id：打开你的智能体编辑界面，网址的结构应该是这样的：</p><p><a href="https://www.coze.cn/space/%22%E4%BD%A0%E7%9A%84USER-ID%22/bot/%22%E4%BD%A0%E7%9A%84BOT-ID%22" target="_blank" rel="noopener noreferrer">https://www.coze.cn/space/&quot;你的USER-ID&quot;/bot/&quot;你的BOT-ID&quot;</a><br> 如何获取access_token：请参考上述“三、调用的前置准备”，请注意，令牌仅在生成时展示一次，请即刻复制并保存。另外，设置access_token 时不要忘记加上“Bearer pat_”的前缀。</p><p>（三）构建请求<br> api_url = &#39;<a href="https://api.coze.cn/v3/chat" target="_blank" rel="noopener noreferrer">https://api.coze.cn/v3/chat</a>&#39;<br> headers = {<br> &#39;Authorization&#39;: access_token,<br> &#39;Content-Type&#39;: &#39;application/json&#39;<br> }<br> body = {<br> &quot;bot_id&quot;: bot_id,<br> &quot;user_id&quot;: user_id,<br> &quot;stream&quot;: True,<br> &quot;auto_save_history&quot;: not(True),<br> &quot;additional_messages&quot;: messages<br> }<br> response = requests.post(api_url, headers=headers, json=body)<br> #print(response)<br> 这里要注意，stream为True时，auto_save_history只能为False；stream为False时，auto_save_history只能为True，否则会报错。</p><p>messages就是常规格式，比如：</p><p>messages = [<br> {&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;你是智能助手&quot;,},<br> {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;请回答我的问题&quot;,},<br> ]<br> （四）流式输出<br> 这里讲流式输出，我们先来了解一下流式输出的结构：</p><p>扣子 - 开发指南 - 流式输出结构<br><a href="http://xn--www-4m0a.coze.cn/docs/developer_guides/get_chat_response" target="_blank" rel="noopener noreferrer">​www.coze.cn/docs/developer_guides/get_chat_response</a><br> 流式输出的有效字段是在 event =&#39;conversation.message.delta&#39; 的前提下，data 返回值中的&quot;content&quot;，具体代码如下：</p><p>for line in response.iter_lines():<br> decoded_line = line.decode(&#39;utf-8&#39;,errors=&#39;ignore&#39;) #解码<br> #print(decoded_line)<br> if decoded_line.startswith(&quot;event:&quot;): #标记event<br> event = decoded_line[6:]<br> #print(event)<br> if decoded_line.startswith(&quot;data:&quot;):<br> event_data = json.loads(decoded_line[5:])<br> #print(event_data)<br> if event == &#39;conversation.message.delta&#39;: #流式输出标记<br> sys.stdout.write(event_data[&quot;content&quot;])<br> time.sleep(0.1)<br> 流式输出有个前提，就是你的智能体最后一步是大语言模型的输出，或者你的智能体有消息模块来展示大语言模型的流式输出结果。假如你的智能体本身就无法将结果流式输出，那么通过API也是无法办到的。具体的你可以在自己的智能体编辑页面尝试一下，看看是不是能够流式输出。</p><p>（五）非流式输出<br> 非流式输出反而更复杂一些。</p><p>你要设置 stream = false，auto_save_history=true，表示使用非流式响应，并记录历史消息。<br> 你需要记录会话的 Conversation ID 和 Chat ID，用于后续查看详细信息。<br> 定期轮询查看对话详情接口，建议每次间隔 1 秒以上，直到会话状态流转为终态，即 status 为 completed 或 required_action。<br> 调用查看对话消息详情接口，查询模型生成的最终结果。<br> 具体代码如下：</p><p>response = response.json()<br> #print(response)</p><p>conversation_id = response[&#39;data&#39;].get(&#39;conversation_id&#39;)<br> chat_id = response[&#39;data&#39;].get(&#39;id&#39;)<br> print(f&#39;Chat_ID:{conversation_id};\\nConversation_ID:{conversation_id}&#39;)</p><p>retrieve_url = f&#39;<a href="https://api.coze.cn/v3/chat/retrieve?conversation_id=%7Bconversation_id%7D&amp;chat_id=%7Bchat_id%7D" target="_blank" rel="noopener noreferrer">https://api.coze.cn/v3/chat/retrieve?conversation_id={conversation_id}&amp;chat_id={chat_id}</a>&#39;<br> while requests.get(retrieve_url, headers=headers).json()[&#39;data&#39;][&#39;status&#39;] != &quot;completed&quot;:<br> time.sleep(0.5)<br> print(&quot;coze bot wait ......&quot;)</p><p>message_url = f&#39;<a href="https://api.coze.cn/v3/chat/message/list?chat_id=%7Bchat_id%7D&amp;conversation_id=%7Bconversation_id%7D" target="_blank" rel="noopener noreferrer">https://api.coze.cn/v3/chat/message/list?chat_id={chat_id}&amp;conversation_id={conversation_id}</a>&#39;<br> message_response = requests.get(message_url, headers=headers).json()<br> event_data_answer = message_response[&#39;data&#39;][1]<br> output = event_data_answer[&quot;content&quot;]<br> print(output)<br> 至此，COZE专业版API调用的核心部分就讲完啦，希望对大家有帮助。</p><p>（六）知识库召回结果<br> 如果你的智能体里面有用到知识库，那么 Coze Bot 的返回结果里是有知识库的RAG召回结果的，甚至还有召回内容所在知识库的页面link，如果你需要的话，可以通过下面的方式调用：</p><p>知识库的召回内容是在 event = &#39;conversation.message.completed&#39; 时（流式输出）且 event_data[&#39;type&#39;] = &#39;verbose&#39; 时，event_data_content[&quot;msg_type&quot;] = &quot;knowledge_recall&quot; 下的内容，具体地，我们可以写出如下函数来解析响应的内容：</p><p>def get_coze_rag(event_data):</p><pre><code>result = list()

if event_data[&#39;type&#39;]==&#39;verbose&#39;:
    
    event_data_content = json.loads(event_data[&quot;content&quot;])
    #print(json.dumps(event_data_content, indent=4,ensure_ascii=False))

    if event_data_content[&quot;msg_type&quot;]==&quot;knowledge_recall&quot;:
        event_data_content_data = json.loads(event_data_content[&quot;data&quot;])
        #print(json.dumps(event_data_content_data, indent=4,ensure_ascii=False))
        
        event_chunks = event_data_content_data[&#39;chunks&#39;]
        for event_chunk in event_chunks:
            knowledge_slice = event_chunk[&#39;slice&#39;]
            result.append(knowledge_slice)
            knowledge_url = event_chunk[&#39;meta&#39;][&#39;link&#39;][&#39;url&#39;].replace(&#39;u0026&#39;, &#39;&amp;&#39;)
            result.append(knowledge_url)
            
return result
</code></pre><p>这个函数的输入是响应流event_data，输出的result为由召回片段和召回片段所在的知识库页面link组成的list。</p><p>由此，对于流式输出，我们的改写如下：</p><p>knowledge_results = []</p><p>for line in response.iter_lines():<br> decoded_line = line.decode(&#39;utf-8&#39;,errors=&#39;ignore&#39;) #解码<br> #print(decoded_line)<br> if decoded_line.startswith(&quot;event:&quot;): #标记event<br> event = decoded_line[6:]<br> #print(event)<br> if decoded_line.startswith(&quot;data:&quot;):<br> event_data = json.loads(decoded_line[5:])<br> #print(event_data)<br> if event == &#39;conversation.message.delta&#39;: #流式输出标记<br> sys.stdout.write(event_data[&quot;content&quot;])<br> time.sleep(0.1)<br> if event == &#39;conversation.message.completed&#39;: #知识库、最终完整输出标记<br> knowledge_results = knowledge_results + get_coze_rag(event_data)</p><p>print(f&quot;\\n\\n知识库召回片段：{knowledge_results}&quot;)<br> 对于非流式输出，我们的改写如下：</p><p>response = response.json()<br> #print(response)</p><p>conversation_id = response[&#39;data&#39;].get(&#39;conversation_id&#39;)<br> chat_id = response[&#39;data&#39;].get(&#39;id&#39;)<br> print(f&#39;Chat_ID:{conversation_id};\\nConversation_ID:{conversation_id}&#39;)</p><p>retrieve_url = f&#39;<a href="https://api.coze.cn/v3/chat/retrieve?conversation_id=%7Bconversation_id%7D&amp;chat_id=%7Bchat_id%7D" target="_blank" rel="noopener noreferrer">https://api.coze.cn/v3/chat/retrieve?conversation_id={conversation_id}&amp;chat_id={chat_id}</a>&#39;<br> while requests.get(retrieve_url, headers=headers).json()[&#39;data&#39;][&#39;status&#39;] != &quot;completed&quot;:<br> time.sleep(0.5)<br> print(&quot;coze bot wait ......&quot;)</p><p>message_url = f&#39;<a href="https://api.coze.cn/v3/chat/message/list?chat_id=%7Bchat_id%7D&amp;conversation_id=%7Bconversation_id%7D" target="_blank" rel="noopener noreferrer">https://api.coze.cn/v3/chat/message/list?chat_id={chat_id}&amp;conversation_id={conversation_id}</a>&#39;<br> message_response = requests.get(message_url, headers=headers).json()</p><p>event_data_knowledge = message_response[&#39;data&#39;][0]<br> knowledge_results = get_coze_rag(event_data_knowledge)</p><p>event_data_answer = message_response[&#39;data&#39;][1]<br> output = event_data_answer[&quot;content&quot;]</p><p>print(output)<br> print(f&quot;\\n知识库召回片段：{knowledge_results}&quot;)<br> 上面所有代码均实测可用无报错，但也均预留了print调试接口，以供遇到bug时调试。当然，报错时求助大模型也是一个好主意（推荐DeepSeek）。</p><p>编辑于 2024-10-15 20:51・IP 属地上海<br> Python<br> API<br> coze专业版<br> ​赞同 1​<br> ​2 条评论<br> ​分享<br> ​喜欢<br> ​收藏<br> ​申请转载<br> ​</p><p>赞同 1</p><p>​<br> 分享</p><p>理性发言，友善互动</p><p>2 条评论<br> 默认<br> 最新<br> 白笑猫<br> 白笑猫<br> 可以出个工作流API调用吗谢谢[爱]</p><p>02-21 · 广东<br> ​回复<br> ​1<br> DefinitelyFly<br> DefinitelyFly<br> 作者<br> 我找了一下 COZE好像不支持直接调用工作流哈 必须包装为智能体或者应用后才能发布API</p><p>03-10 · 上海<br> ​回复<br> ​喜欢<br> 推荐阅读<br> 基于coze创建自己的私人知识库<br> corz是字节跳动发布的“一站式AI开发平台“，看官方介绍为： Coze is a next-generation AI Bot development platform. Regardless of your programming experience, Coze enables you to e…</p><p>Ryan<br> 人人都学得会用coze工作流搭建|保姆级工作流教程<br> 之前我们写了一篇详细介绍如何通过coze搭建bot（机器人）的详细教程。 100%免费用GPT4 Turbo！Coze（扣子）平台保姆级创建bot（智能体）教程这篇阅读量还不错，今天我们来介绍一下比较难的 …</p><p>小吴科技屋<br> 千亿参数，百万序列 | XTuner 超长上下文训练方案<br> 千亿参数，百万序列 | XTuner 超长上下文训练方案<br> OpenMMLab<br> coze教程 | 04 工作流之大模型节点<br> 1 大模型节点概述首先看一下大模型节点的配置： 配置可以看到5个部分： 1.1 模型这次介绍的是coze国内版，如果是海外版的话模型的选择是不一样的。根据自己的需求特别要注意一下模型的token…</p><p>荣姐聊AI<br> 发表于AI智能体</p><p>选择语言</p>`,57)]))}const d=t(a,[["render",s],["__file","cozeAPI.html.vue"]]),_=JSON.parse('{"path":"/docs/coze_hiagent/cozeAPI.html","title":"5千字长文：COZE专业版API调用超详细教程（Python）","lang":"zh-CN","frontmatter":{"description":"5千字长文：COZE专业版API调用超详细教程（Python） DefinitelyFly 随着字节在大模型军备竞赛中一骑绝尘，越来越多的小伙伴开始注意到扣子（COZE）这个强大的智能体工作流搭建平台。然而，不得不说，扣子的官方教程实在是出了名的草率，既没有示例代码，排版布局也十分混乱，扣子基础版、扣子专业版、豆包大模型、火山引擎、火山方舟让人傻傻分不...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/docs/coze_hiagent/cozeAPI.html"}],["meta",{"property":"og:site_name","content":"南开WIKI"}],["meta",{"property":"og:title","content":"5千字长文：COZE专业版API调用超详细教程（Python）"}],["meta",{"property":"og:description","content":"5千字长文：COZE专业版API调用超详细教程（Python） DefinitelyFly 随着字节在大模型军备竞赛中一骑绝尘，越来越多的小伙伴开始注意到扣子（COZE）这个强大的智能体工作流搭建平台。然而，不得不说，扣子的官方教程实在是出了名的草率，既没有示例代码，排版布局也十分混乱，扣子基础版、扣子专业版、豆包大模型、火山引擎、火山方舟让人傻傻分不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-01T07:14:53.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-01T07:14:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"5千字长文：COZE专业版API调用超详细教程（Python）\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-01T07:14:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Because\\",\\"url\\":\\"https://github.com/Because66666\\"}]}"]]},"git":{"createdTime":1743035930000,"updatedTime":1743491693000,"contributors":[{"name":"Because66666","username":"Because66666","email":"z66666z@163.com","commits":2,"url":"https://github.com/Because66666"}]},"readingTime":{"minutes":9.09,"words":2727},"filePathRelative":"docs/coze&hiagent/cozeAPI.md","localizedDate":"2025年3月27日","autoDesc":true}');export{d as comp,_ as data};
