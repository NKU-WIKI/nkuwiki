---
description: 
globs: 
alwaysApply: true
---
# 数据库操作规范

## 1. 数据库连接管理 (`db_pool_manager.py`)

项目采用基于 `mysql-connector-python` 的高级数据库连接池，具备多实例协调和动态调整能力。

### 核心特性
- **多实例协调**：使用 Redis 在多个服务实例间同步连接池状态，避免超出数据库最大连接数。
- **动态池大小**：根据活跃实例数量和系统负载动态计算并调整每个实例的连接池大小。
- **文件锁**：通过 `/tmp/nkuwiki_db_lock` 确保在多进程环境中只有一个实例负责初始化。
- **心跳与监控**：每个实例通过 Redis 定期报告心跳和性能指标。

### 获取连接

所有数据库操作都应通过 `get_db_connection` 上下文管理器获取连接，以确保连接的正确获取和释放。

```python
# etl/load/db_pool_manager.py

from contextlib import contextmanager
from etl.load.db_pool_manager import get_connection as get_pooled_connection, release_connection
from core.utils.logger import register_logger

logger = register_logger(__name__)

@contextmanager
def get_db_connection():
    """
    推荐使用的数据库连接上下文管理器。
    自动处理连接的获取和释放。
    """
    connection = None
    try:
        # 从高级连接池获取连接
        connection = get_pooled_connection()
        yield connection
    except Exception as e:
        logger.error(f"数据库连接上下文管理器出错: {str(e)}")
        # 异常时也应尝试释放连接
        if connection:
            release_connection(connection, has_error=True)
        raise
    finally:
        # 正常退出时释放连接
        if connection:
            release_connection(connection)

# 使用示例
try:
    with get_db_connection() as conn:
        with conn.cursor(dictionary=True) as cursor:
            cursor.execute("SELECT * FROM some_table LIMIT 1")
            result = cursor.fetchone()
            print(result)
except Exception as e:
    logger.error(f"数据库操作失败: {e}")
```

## 2. 核心数据库异步操作 (`db_core.py`)

数据库核心操作层 (`db_core.py`) 被设计为**异步优先**。所有操作均在独立的线程池 (`ThreadPoolExecutor`) 中执行，以防止阻塞主应用的 `asyncio` 事件循环。

### 常用异步函数

- `execute_custom_query(query, params, fetch)`: 执行任意自定义SQL。
- `insert_record(table_name, data)`: 插入单条记录。
- `update_record(table_name, record_id, data)`: 根据ID更新记录。
- `query_records(table_name, conditions, fields, order_by, limit, offset)`: 功能强大的查询函数。
- `batch_insert(table_name, records, batch_size)`: 高效的批量插入。
- `get_all_tables()`: 获取所有表名。

### 使用示例

所有 `db_core` 函数都必须使用 `await` 调用。

```python
import asyncio
from etl.load import db_core

async def main():
    # 示例1: 插入一条记录
    new_user_data = {"nickname": "async_user", "openid": "test_openid_12345"}
    user_id = await db_core.insert_record("wxapp_users", new_user_data)
    print(f"插入用户成功，ID: {user_id}")

    # 示例2: 查询记录
    query_conditions = {"nickname": "async_user"}
    result = await db_core.query_records(
        table_name="wxapp_users",
        conditions=query_conditions,
        fields=["openid", "nickname", "create_time"],
        limit=1
    )
    if result['data']:
        print("查询结果:", result['data'][0])

    # 示例3: 批量插入
    new_posts = [
        {"openid": "test_openid_12345", "title": "帖子A", "content": "内容A"},
        {"openid": "test_openid_12345", "title": "帖子B", "content": "内容B"},
    ]
    inserted_count = await db_core.batch_insert("wxapp_posts", new_posts)
    print(f"批量插入 {inserted_count} 条帖子成功")

    # 示例4: 执行自定义SQL
    custom_sql = "SELECT COUNT(*) as count FROM wxapp_posts WHERE openid = %s"
    count_result = await db_core.execute_custom_query(custom_sql, ["test_openid_12345"])
    print("帖子总数:", count_result[0]['count'])

if __name__ == "__main__":
    asyncio.run(main())
```

## 3. 表结构管理 (`table_manager.py`)

表结构的管理由 `TableManager` 负责，其设计同样是异步的，并支持通过命令行进行操作。

### 核心特性
- **SQL文件驱动**：表结构定义在 `etl/load/mysql_tables/` 目录下的各个 `.sql` 文件中，文件名即表名（如 `wxapp_users.sql`）。
- **异步操作**：所有管理功能（创建、删除、查询信息）都是 `async` 方法。
- **命令行支持**：可作为脚本运行，方便地进行数据库初始化和维护。

### 使用示例

```python
import asyncio
from etl.load.table_manager import TableManager

async def manage_tables():
    manager = TableManager()

    # 获取所有可用的表定义
    available_tables = manager.get_available_table_definitions()
    print("可用的表定义:", available_tables)

    # 检查 'wxapp_users' 表是否存在
    exists = await manager.table_exists('wxapp_users')
    print(f"'wxapp_users' 表是否存在: {exists}")

    # 获取表信息
    if exists:
        info = await manager.get_table_info('wxapp_users')
        if info:
            print(f"'wxapp_users' 表信息: {info.get('record_count', 0)} 条记录")

    # 重新创建所有表（危险操作！）
    # await manager.recreate_tables(force=True)
    # print("所有表已重建")

if __name__ == "__main__":
    asyncio.run(manage_tables())
```
